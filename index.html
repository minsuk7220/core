<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>잼–코어 계산기 (3코어 동시 최적화)</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: Arial, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; margin: 24px; color: #111; }
    h1 { margin: 0 0 12px; }
    .sub { color:#666; margin-bottom: 20px; }
    .row { display:flex; flex-wrap: wrap; gap:16px; }
    .card { border:1px solid #ddd; border-radius:12px; padding:14px; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.04); }
    .card h3 { margin:0 0 10px; font-size:16px; }
    label { display:inline-flex; align-items:center; gap:8px; margin:6px 10px 6px 0; font-size:14px; }
    input[type=number] { width:96px; padding:6px 8px; border:1px solid #ccc; border-radius:8px; }
    button { padding:8px 12px; border:1px solid #222; background:#111; color:#fff; border-radius:10px; cursor:pointer; }
    button.secondary { background:#f7f7f7; color:#111; border-color:#ddd; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    ul { margin:8px 0 0; padding-left:18px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f1f5f9; border:1px solid #e5e7eb; font-size:12px; margin-right:6px; }
    .footer { margin-top: 10px; font-size:12px; color:#666; }
    .grid { display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
    .result { margin-top:18px; border:1px dashed #ccc; border-radius:12px; padding:14px; }
    .ok { color:#0a7a30; }
    .bad { color:#b00020; }
    table { width:100%; border-collapse: collapse; margin-top:10px; }
    th, td { border:1px solid #eee; padding:8px; text-align:center; font-size:13px; }
    th { background:#fafafa; }
    .muted { color:#666; }
    .wrap { word-break: break-word; }
  </style>
</head>
<body>
  <h1>잼–코어 계산기</h1>
  <div class="sub">조건 만족 실패 시, 이제는 실제 <b>중복 금지 조건을 고려한 부족분 가이드</b>도 함께 표시됩니다.</div>

  <div class="grid">
    <div class="card">
      <h3>① 잼 추가</h3>
      <label>의지력 <input type="number" id="gemWill" min="1" /></label>
      <label>질서 <input type="number" id="gemOrder" min="0" /></label>
      <button id="addGemBtn">추가</button>
      <button class="secondary" id="seedBtn">예시 불러오기</button>
      <ul id="gemList"></ul>
      <div class="footer muted">형식: (의지력, 질서). 예: (3,5)</div>
    </div>

    <div class="card">
      <h3>② 코어 설정 (최대 3개)</h3>
      <div id="coreInputs"></div>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button id="addCoreBtn">코어 추가</button>
        <button class="secondary" id="clearCoresBtn">초기화</button>
      </div>
      <div class="footer muted">각 코어: 의지력 제한 / 필요 질서</div>
    </div>

    <div class="card">
      <h3>③ 계산</h3>
      <div class="row">
        <button id="calcBtn">최적 조합 계산</button>
      </div>
    </div>
  </div>

  <div class="result" id="resultBox">결과가 여기에 표시됩니다.</div>
  <div class="result" id="hintBox" style="display:none"></div>

<script>
  let gems = [];
  let cores = [];
  const $ = (sel) => document.querySelector(sel);
  const listEl = $('#gemList');
  const coreInputsEl = $('#coreInputs');
  const resultBox = $('#resultBox');
  const hintBox = $('#hintBox');

  function renderGems() {
    listEl.innerHTML = '';
    gems.forEach((g, i) => {
      const li = document.createElement('li');
      li.className = 'wrap';
      li.innerHTML = `#${i+1} <span class="pill">의:${g.will}</span><span class="pill">질:${g.order}</span> <button class="secondary" onclick="removeGem(${i})">삭제</button>`;
      listEl.appendChild(li);
    });
  }
  function removeGem(i) { gems.splice(i,1); renderGems(); }

  function renderCores() {
    coreInputsEl.innerHTML = '';
    cores.forEach((c, idx) => {
      const row = document.createElement('div');
      row.className = 'row';
      row.style.alignItems = 'center';
      row.style.marginBottom = '8px';
      row.innerHTML = `
        <div class="pill">코어 ${idx+1}</div>
        <label>의지력 제한 <input type="number" min="1" value="${c.limit}" onchange="updateCore(${idx}, 'limit', this.value)"/></label>
        <label>필요 질서 <input type="number" min="0" value="${c.target}" onchange="updateCore(${idx}, 'target', this.value)"/></label>
        <button class="secondary" onclick="removeCore(${idx})">삭제</button>
      `;
      coreInputsEl.appendChild(row);
    });
  }
  function updateCore(i, key, val) { cores[i][key] = parseInt(val||'0'); }
  function removeCore(i) { cores.splice(i,1); renderCores(); }

  $('#addGemBtn').addEventListener('click', () => {
    const w = parseInt($('#gemWill').value);
    const o = parseInt($('#gemOrder').value);
    if (Number.isNaN(w) || Number.isNaN(o) || w <= 0 || o < 0) return;
    gems.push({ will: w, order: o });
    renderGems();
  });
  $('#seedBtn').addEventListener('click', () => {
    gems = [
      {will:3, order:5}, {will:3, order:5}, {will:4, order:5},
      {will:5, order:4}, {will:5, order:5}
    ];
    renderGems();
  });
  $('#addCoreBtn').addEventListener('click', () => {
    if (cores.length >= 3) { alert('최대 3개의 코어까지 가능합니다.'); return; }
    cores.push({ limit: 0, target: 0 });
    renderCores();
  });
  $('#clearCoresBtn').addEventListener('click', () => { cores = []; renderCores(); });

  $('#calcBtn').addEventListener('click', () => {
    const report = solveMultiCore(gems, cores);
    renderResult(report);
  });

  function solveMultiCore(inputGems, inputCores) {
    const nC = inputCores.length;
    if (nC === 0) return { ok:false, reason:'코어가 없습니다.' };
    const G = inputGems.map((g, idx) => ({...g, idx}));
    G.sort((a,b) => (b.order - a.order) || (a.will - b.will));
    const suffixOrder = new Array(G.length+1).fill(0);
    for (let i = G.length-1; i >= 0; i--) suffixOrder[i] = suffixOrder[i+1] + G[i].order;

    const sums = Array.from({length:nC}, () => ({ will:0, order:0 }));
    const assign = new Array(G.length).fill(-1);
    let best = null;

    function willOver() {
      for (let c=0; c<nC; c++) if (sums[c].will > (inputCores[c].limit||0)) return true;
      return false;
    }
    function impossibleEvenIfUseAll(i) {
      const remOrder = suffixOrder[i];
      let needSum = 0;
      for (let c=0; c<nC; c++) {
        const need = Math.max(0, (inputCores[c].target||0) - sums[c].order);
        needSum += need;
      }
      return remOrder < needSum;
    }
    function allTargetsMet() {
      for (let c=0; c<nC; c++) if (sums[c].order < (inputCores[c].target||0)) return false;
      return true;
    }
    function totalOrderSum() { return sums.reduce((acc, s) => acc + s.order, 0); }

    function dfs(i) {
      if (willOver()) return;
      if (impossibleEvenIfUseAll(i)) return;
      if (i === G.length) {
        if (!allTargetsMet()) return;
        const tot = totalOrderSum();
        if (!best || tot > best.totalOrder) {
          best = { totalOrder: tot, sums: sums.map(s=>({...s})), assign:[...assign] };
        }
        return;
      }
      assign[i] = -1; dfs(i+1);
      for (let c=0; c<nC; c++) {
        assign[i] = c;
        sums[c].will += G[i].will;
        sums[c].order += G[i].order;
        dfs(i+1);
        sums[c].will -= G[i].will;
        sums[c].order -= G[i].order;
      }
      assign[i] = -1;
    }
    dfs(0);
    if (!best) return { ok:false, reason:'조건을 동시에 만족하는 조합이 없습니다.', partial: evaluateDeficit(G, inputCores) };

    const perCore = Array.from({length:nC}, () => []);
    best.assign.forEach((c, gi) => { if (c >= 0) perCore[c].push(G[gi]); });
    perCore.forEach(arr => arr.sort((a,b)=>a.idx-b.idx));
    return { ok:true, totalOrder:best.totalOrder, cores: best.sums.map((s,i)=>({will:s.will, order:s.order, gems:perCore[i]})) };
  }

  function evaluateDeficit(gemsArr, coresArr){
    return coresArr.map((c,idx)=>{
      let bestOrder=0, usedWill=0;
      for (let mask=0; mask<(1<<gemsArr.length); mask++){
        let sumW=0,sumO=0;
        for (let i=0;i<gemsArr.length;i++) if(mask&(1<<i)){ sumW+=gemsArr[i].will; sumO+=gemsArr[i].order; }
        if(sumW<=c.limit && sumO>bestOrder){ bestOrder=sumO; usedWill=sumW; }
      }
      return {core:idx+1, limit:c.limit, target:c.target, usedWill, bestOrder, deficit:Math.max(0,c.target-bestOrder)};
    });
  }

  function renderResult(report) {
    hintBox.style.display='none'; hintBox.innerHTML='';
    if(!report.ok){
      resultBox.innerHTML = `<div class="bad"><b>실패</b> — ${report.reason}</div>`;
      if(report.partial){
        let rows='';
        report.partial.forEach(r=>{
          rows+=`<tr><td>${r.core}</td><td>${r.limit}</td><td>${r.target}</td><td>${r.usedWill}</td><td>${r.bestOrder}</td><td>${r.deficit}</td></tr>`;
        });
        hintBox.style.display='block';
        hintBox.innerHTML=`<div class="bad"><b>부족분 가이드</b></div><table><thead><tr><th>코어</th><th>의지 제한</th><th>필요 질서</th><th>사용 의지</th><th>달성 질서</th><th>부족 질서</th></tr></thead><tbody>${rows}</tbody></table>`;
      }
      return;
    }
    let html = `<div class="ok"><b>성공</b> — 질서 총합 <b>${report.totalOrder}</b></div>`;
    html+='<table><thead><tr><th>코어</th><th>의지력 합</th><th>질서 합</th><th>잼 조합</th></tr></thead><tbody>';
    report.cores.forEach((c,idx)=>{
      const combo=c.gems.length?c.gems.map(g=>`(${g.will},${g.order})`).join(' + '):'<span class="muted">없음</span>';
      html+=`<tr><td>${idx+1}</td><td>${c.will}</td><td>${c.order}</td><td class="wrap">${combo}</td></tr>`;
    });
    html+='</tbody></table>';
    resultBox.innerHTML=html;
  }

  renderGems();
  renderCores();
</script>
</body>
</html>
