<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>잼–코어 계산기 (3코어 동시 최적화)</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: Arial, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; margin: 24px; color: #111; }
    h1 { margin: 0 0 12px; }
    .sub { color:#666; margin-bottom: 20px; }
    .row { display:flex; flex-wrap: wrap; gap:16px; }
    .card { border:1px solid #ddd; border-radius:12px; padding:14px; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.04); }
    .card h3 { margin:0 0 10px; font-size:16px; }
    label { display:inline-flex; align-items:center; gap:8px; margin:6px 10px 6px 0; font-size:14px; }
    input[type=number] { width:96px; padding:6px 8px; border:1px solid #ccc; border-radius:8px; }
    button { padding:8px 12px; border:1px solid #222; background:#111; color:#fff; border-radius:10px; cursor:pointer; }
    button.secondary { background:#f7f7f7; color:#111; border-color:#ddd; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    ul { margin:8px 0 0; padding-left:18px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f1f5f9; border:1px solid #e5e7eb; font-size:12px; margin-right:6px; }
    .footer { margin-top: 10px; font-size:12px; color:#666; }
    .grid { display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
    .result { margin-top:18px; border:1px dashed #ccc; border-radius:12px; padding:14px; }
    .ok { color:#0a7a30; }
    .bad { color:#b00020; }
    table { width:100%; border-collapse: collapse; margin-top:10px; }
    th, td { border:1px solid #eee; padding:8px; text-align:center; font-size:13px; }
    th { background:#fafafa; }
    .muted { color:#666; }
    .wrap { word-break: break-word; }
  </style>
</head>
<body>
  <h1>잼–코어 계산기</h1>
  <div class="sub">조건 만족 실패 시, 이제는 실제 <b>중복 금지 조건을 고려한 부족분 가이드</b>도 함께 표시됩니다.</div>

  <div class="grid">
    <div class="card">
      <h3>① 잼 추가</h3>
      <label>의지력 <input type="number" id="gemWill" min="1" /></label>
      <label>질서 <input type="number" id="gemOrder" min="0" /></label>
      <button id="addGemBtn">추가</button>
      <button class="secondary" id="seedBtn">예시 불러오기</button>
      <ul id="gemList"></ul>
      <div class="footer muted">형식: (의지력, 질서). 예: (3,5)</div>
    </div>

    <div class="card">
      <h3>② 코어 설정 (최대 3개)</h3>
      <div id="coreInputs"></div>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button id="addCoreBtn">코어 추가</button>
        <button class="secondary" id="clearCoresBtn">초기화</button>
      </div>
      <div class="footer muted">각 코어: 의지력 제한 / 필요 질서</div>
    </div>

    <div class="card">
      <h3>③ 계산</h3>
      <div class="row">
        <button id="calcBtn">최적 조합 계산</button>
        <button class="secondary" id="exportBtn">데이터 내보내기</button>
        <button class="secondary" id="importBtn">데이터 불러오기</button>
      </div>
    </div>
  </div>

  <div class="result" id="resultBox">결과가 여기에 표시됩니다.</div>
  <div class="result" id="hintBox" style="display:none"></div>

<script>
  let gems = [];
  let cores = [];
  const $ = (sel) => document.querySelector(sel);
  const listEl = $('#gemList');
  const coreInputsEl = $('#coreInputs');
  const resultBox = $('#resultBox');
  const hintBox = $('#hintBox');

  function renderGems() {
    listEl.innerHTML = '';
    gems.forEach((g, i) => {
      const li = document.createElement('li');
      li.className = 'wrap';
      li.innerHTML = `#${i+1} <span class="pill">의:${g.will}</span><span class="pill">질:${g.order}</span> <button class="secondary" onclick="removeGem(${i})">삭제</button>`;
      listEl.appendChild(li);
    });
  }
  function removeGem(i) { gems.splice(i,1); renderGems(); }

  function renderCores() {
    coreInputsEl.innerHTML = '';
    cores.forEach((c, idx) => {
      const row = document.createElement('div');
      row.className = 'row';
      row.style.alignItems = 'center';
      row.style.marginBottom = '8px';
      row.innerHTML = `
        <div class="pill">코어 ${idx+1}</div>
        <label>의지력 제한 <input type="number" min="1" value="${c.limit}" onchange="updateCore(${idx}, 'limit', this.value)"/></label>
        <label>필요 질서 <input type="number" min="0" value="${c.target}" onchange="updateCore(${idx}, 'target', this.value)"/></label>
        <button class="secondary" onclick="removeCore(${idx})">삭제</button>
      `;
      coreInputsEl.appendChild(row);
    });
  }
  function updateCore(i, key, val) { cores[i][key] = parseInt(val||'0'); }
  function removeCore(i) { cores.splice(i,1); renderCores(); }

  $('#addGemBtn').addEventListener('click', () => {
    const w = parseInt($('#gemWill').value);
    const o = parseInt($('#gemOrder').value);
    if (Number.isNaN(w) || Number.isNaN(o)) return;
    // 유효 범위 체크 (의지 3~8, 질서 0~5)
    if (w < 3 || w > 8 || o < 0 || o > 5) {
      alert('의지력은 3~8, 질서포인트는 0~5 범위에서만 유효합니다.');
      return;
    }
    gems.push({ will: w, order: o });
    renderGems();
  });
  $('#seedBtn').addEventListener('click', () => {
    gems = [
      {will:3, order:5}, {will:3, order:5}, {will:4, order:5},
      {will:5, order:4}, {will:5, order:5}
    ];
    renderGems();
  });
  $('#addCoreBtn').addEventListener('click', () => {
    if (cores.length >= 3) { alert('최대 3개의 코어까지 가능합니다.'); return; }
    cores.push({ limit: 0, target: 0 });
    renderCores();
  });
  $('#clearCoresBtn').addEventListener('click', () => { cores = []; renderCores(); });

  $('#calcBtn').addEventListener('click', () => {
    const report = solveMultiCore(gems, cores);
    renderResult(report);
  });

  function solveMultiCore(inputGems, inputCores) {
    const nC = inputCores.length;
    if (nC === 0) return { ok:false, reason:'코어가 없습니다.' };
    const G = inputGems.map((g, idx) => ({...g, idx}));
    G.sort((a,b) => (b.order - a.order) || (a.will - b.will));
    const suffixOrder = new Array(G.length+1).fill(0);
    for (let i = G.length-1; i >= 0; i--) suffixOrder[i] = suffixOrder[i+1] + G[i].order;

    const sums = Array.from({length:nC}, () => ({ will:0, order:0 }));
    const assign = new Array(G.length).fill(-1);
    let best = null;

    function willOver() {
      for (let c=0; c<nC; c++) if (sums[c].will > (inputCores[c].limit||0)) return true;
      return false;
    }
    function impossibleEvenIfUseAll(i) {
      const remOrder = suffixOrder[i];
      let needSum = 0;
      for (let c=0; c<nC; c++) {
        const need = Math.max(0, (inputCores[c].target||0) - sums[c].order);
        needSum += need;
      }
      return remOrder < needSum;
    }
    function allTargetsMet() {
      for (let c=0; c<nC; c++) if (sums[c].order < (inputCores[c].target||0)) return false;
      return true;
    }
    function totalOrderSum() { return sums.reduce((acc, s) => acc + s.order, 0); }

    function dfs(i) {
      if (willOver()) return;
      if (impossibleEvenIfUseAll(i)) return;
      if (i === G.length) {
        if (!allTargetsMet()) return;
        const tot = totalOrderSum();
        if (!best || tot > best.totalOrder) {
          best = { totalOrder: tot, sums: sums.map(s=>({...s})), assign:[...assign] };
        }
        return;
      }
      assign[i] = -1; dfs(i+1);
      for (let c=0; c<nC; c++) {
        assign[i] = c;
        sums[c].will += G[i].will;
        sums[c].order += G[i].order;
        dfs(i+1);
        sums[c].will -= G[i].will;
        sums[c].order -= G[i].order;
      }
      assign[i] = -1;
    }
    dfs(0);
    if (!best) return { ok:false, reason:'조건을 동시에 만족하는 조합이 없습니다.', partial: evaluateDeficit(G, inputCores) };

    const perCore = Array.from({length:nC}, () => []);
    best.assign.forEach((c, gi) => { if (c >= 0) perCore[c].push(G[gi]); });
    perCore.forEach(arr => arr.sort((a,b)=>a.idx-b.idx));
    return { ok:true, totalOrder:best.totalOrder, cores: best.sums.map((s,i)=>({will:s.will, order:s.order, gems:perCore[i]})) };
  }

  function evaluateDeficit(gemsArr, coresArr){
    return coresArr.map((c,idx)=>{
      let bestOrder=0, usedWill=0;
      for (let mask=0; mask<(1<<gemsArr.length); mask++){
        let sumW=0,sumO=0;
        for (let i=0;i<gemsArr.length;i++) if(mask&(1<<i)){ sumW+=gemsArr[i].will; sumO+=gemsArr[i].order; }
        if(sumW<=c.limit && sumO>bestOrder){ bestOrder=sumO; usedWill=sumW; }
      }
      return {core:idx+1, limit:c.limit, target:c.target, usedWill, bestOrder, deficit:Math.max(0,c.target-bestOrder)};
    });
  }

  // === 동시 조건을 고려한 1개 신규 잼 권장치 계산 ===
  function isFeasible(gemsArr, coresArr){
    // DFS로 가능 여부만 판정
    const nC=coresArr.length; const G=gemsArr.map((g,i)=>({...g,idx:i}));
    G.sort((a,b)=> (b.order-a.order)||(a.will-b.will));
    const suf=new Array(G.length+1).fill(0); for(let i=G.length-1;i>=0;i--) suf[i]=suf[i+1]+G[i].order;
    const sums=Array.from({length:nC},()=>({will:0,order:0}));
    function over(){ for(let c=0;c<nC;c++) if(sums[c].will>(coresArr[c].limit||0)) return true; return false; }
    function need(i){ let n=0; for(let c=0;c<nC;c++){ n+=Math.max(0,(coresArr[c].target||0)-sums[c].order);} return n; }
    function full(){ for(let c=0;c<nC;c++) if(sums[c].order<(coresArr[c].target||0)) return false; return true; }
    let ok=false;
    (function dfs(i){ if(ok) return; if(over()) return; if(suf[i]<need(i)) return; if(i===G.length){ if(full()) ok=true; return; }
      // skip
      dfs(i+1);
      // assign
      for(let c=0;c<nC;c++){ sums[c].will+=G[i].will; sums[c].order+=G[i].order; dfs(i+1); sums[c].will-=G[i].will; sums[c].order-=G[i].order; if(ok) return; }
    })(0);
    return ok;
  }

  function computeOneGemSuggestions(gemsArr, coresArr){
    if(!coresArr.length) return null;
    // 유효 범위: 의지 3~8, 질서 0~5
    const W_MIN=3, W_MAX=8, O_MIN=0, O_MAX=5;
    const frontier=[];
    for(let w=W_MIN; w<=W_MAX; w++){
      // 가장 작은 질서부터 가능한지 탐색 (0..5)
      let feasibleOrder=null;
      for(let o=O_MIN; o<=O_MAX; o++){
        if(isFeasible([...gemsArr, {will:w, order:o}], coresArr)) { feasibleOrder=o; break; }
      }
      if(feasibleOrder!==null) frontier.push({will:w, minOrder:feasibleOrder});
    }
    if(!frontier.length) return {frontier:[]};
    // 요약 포인트
    let bestMinOrder=frontier[0];
    for(const p of frontier){ if(p.minOrder<bestMinOrder.minOrder || (p.minOrder===bestMinOrder.minOrder && p.will<bestMinOrder.will)) bestMinOrder=p; }
    const bestMinWill = frontier[0]; // 의지 최소는 w 오름차순 첫 원소
    return {frontier, bestMinOrder, bestMinWill, range:{W_MIN,W_MAX,O_MIN,O_MAX}};
  }

  function renderResult(report) {
    hintBox.style.display='none'; hintBox.innerHTML='';
    if(!report.ok){
      resultBox.innerHTML = `<div class=\"bad\"><b>실패</b> — ${report.reason}</div>`;
      if(report.partial){
        let rows='';
        report.partial.forEach(r=>{ rows+=`<tr><td>${r.core}</td><td>${r.limit}</td><td>${r.target}</td><td>${r.usedWill}</td><td>${r.bestOrder}</td><td>${r.deficit}</td></tr>`; });
        hintBox.style.display='block';
        let html = `<div class=\"bad\"><b>부족분 가이드</b></div>`+
          `<table><thead><tr><th>코어</th><th>의지 제한</th><th>필요 질서</th><th>사용 의지</th><th>달성 질서</th><th>부족 질서</th></tr></thead><tbody>${rows}</tbody></table>`;

        // === 신규 잼 추천(1개 추가 시) ===
        const suggest = computeOneGemSuggestions(gems, cores);
        if(suggest && suggest.frontier && suggest.frontier.length){
          const rows2 = suggest.frontier.slice(0,3).map(x=>`<tr><td>${x.will}</td><td>${x.minOrder}</td></tr>`).join('');
          const best1 = suggest.bestMinOrder ? `의지 ≤ <b>${suggest.bestMinOrder.will}</b>, 질서 ≥ <b>${suggest.bestMinOrder.minOrder}</b>` : '불가';
          const best2 = suggest.bestMinWill ? `의지 ≤ <b>${suggest.bestMinWill.will}</b>, 질서 ≥ <b>${suggest.bestMinWill.minOrder}</b>` : '불가';
          html += `
            <div style=\"margin-top:12px\"><b>권장 신규 잼 (1개 추가 시)</b></div>
            <div class=\"muted\">유효 범위 적용: 의지 3~8, 질서 0~5</div>
            <table><thead><tr><th>의지 한도(≤)</th><th>필요 질서(≥)</th></tr></thead><tbody>${rows2}</tbody></table>
            <div class=\"muted\" style=\"margin-top:6px\">요약 — 최소 질서: ${best1} / 최소 의지: ${best2}</div>
          `;
        } else {
          html += `<div class=\"muted\" style=\"margin-top:8px\"><b>신규 잼 1개만으로는</b> 조건을 동시에 만족시킬 수 없습니다. (두 개 이상 필요)</div>`;
        }
        hintBox.innerHTML = html;
      }
      return;
    }
    let html = `<div class=\"ok\"><b>성공</b> — 질서 총합 <b>${report.totalOrder}</b></div>`;
    html+='<table><thead><tr><th>코어</th><th>의지력 합</th><th>질서 합</th><th>잼 조합</th></tr></thead><tbody>';
    report.cores.forEach((c,idx)=>{
      const combo=c.gems.length?c.gems.map(g=>`(${g.will},${g.order})`).join(' + '):'<span class=\"muted\">없음</span>';
      html+=`<tr><td>${idx+1}</td><td>${c.will}</td><td>${c.order}</td><td class=\"wrap\">${combo}</td></tr>`;
    });
    html+='</tbody></table>';
    resultBox.innerHTML=html;
  }

  // JSON 내보내기/불러오기 복원
  document.getElementById('exportBtn').addEventListener('click', ()=>{
    const payload = { gems, cores };
    try {
      navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
      alert('클립보드로 내보냈습니다. 메모장 등에 붙여넣어 보관하세요.');
    } catch(err){
      alert('클립보드 복사 실패: '+err);
    }
  });
  document.getElementById('importBtn').addEventListener('click', ()=>{
    const text = prompt('붙여넣기한 JSON을 입력하세요');
    if(!text) return;
    try{
      const payload = JSON.parse(text);
      if (Array.isArray(payload.gems)) gems = payload.gems.map(x => ({will:+x.will, order:+x.order}));
      if (Array.isArray(payload.cores)) cores = payload.cores.map(x => ({limit:+x.limit, target:+x.target}));
      renderGems(); renderCores();
    }catch(err){
      alert('JSON 파싱 실패: '+err);
    }
  });

  renderGems();
  renderCores();
</script>
</body>
</html>
